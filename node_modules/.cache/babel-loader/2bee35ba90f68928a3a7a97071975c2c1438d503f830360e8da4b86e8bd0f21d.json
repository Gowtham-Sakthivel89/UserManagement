{"ast":null,"code":"// src/store/actions/todoActions.js\nlet nextTodoId = 1;\nexport const loadTodos = username => async dispatch => {\n  dispatch({\n    type: 'LOAD_TODOS_REQUEST'\n  });\n  try {\n    // Mock API call\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Mock data - in a real app, this would come from an API\n    const mockTodos = [{\n      id: nextTodoId++,\n      title: 'Complete the project',\n      completed: false,\n      userId: username\n    }, {\n      id: nextTodoId++,\n      title: 'Prepare for interview',\n      completed: true,\n      userId: username\n    }, {\n      id: nextTodoId++,\n      title: 'Review React concepts',\n      completed: false,\n      userId: username\n    }];\n    dispatch({\n      type: 'LOAD_TODOS_SUCCESS',\n      payload: mockTodos\n    });\n  } catch (error) {\n    dispatch({\n      type: 'TODOS_FAILURE',\n      payload: error.message\n    });\n  }\n};\nexport const addTodo = (title, username) => async dispatch => {\n  try {\n    // Mock API call\n    await new Promise(resolve => setTimeout(resolve, 300));\n    const newTodo = {\n      id: nextTodoId++,\n      title,\n      completed: false,\n      userId: username\n    };\n    dispatch({\n      type: 'ADD_TODO_SUCCESS',\n      payload: newTodo\n    });\n    return {\n      success: true\n    };\n  } catch (error) {\n    dispatch({\n      type: 'TODOS_FAILURE',\n      payload: error.message\n    });\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\nexport const updateTodo = (id, updates) => async dispatch => {\n  try {\n    // Mock API call\n    await new Promise(resolve => setTimeout(resolve, 300));\n    dispatch({\n      type: 'UPDATE_TODO_SUCCESS',\n      payload: {\n        id,\n        ...updates\n      }\n    });\n    return {\n      success: true\n    };\n  } catch (error) {\n    dispatch({\n      type: 'TODOS_FAILURE',\n      payload: error.message\n    });\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\nexport const deleteTodo = id => async dispatch => {\n  try {\n    // Mock API call\n    await new Promise(resolve => setTimeout(resolve, 300));\n    dispatch({\n      type: 'DELETE_TODO_SUCCESS',\n      payload: id\n    });\n    return {\n      success: true\n    };\n  } catch (error) {\n    dispatch({\n      type: 'TODOS_FAILURE',\n      payload: error.message\n    });\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\nexport const setTodoFilter = filter => ({\n  type: 'SET_TODO_FILTER',\n  payload: filter\n});","map":{"version":3,"names":["nextTodoId","loadTodos","username","dispatch","type","Promise","resolve","setTimeout","mockTodos","id","title","completed","userId","payload","error","message","addTodo","newTodo","success","updateTodo","updates","deleteTodo","setTodoFilter","filter"],"sources":["D:/React project/usermanagement/src/store/actions/todoActions.jsx"],"sourcesContent":["// src/store/actions/todoActions.js\r\nlet nextTodoId = 1;\r\n\r\nexport const loadTodos = (username) => async (dispatch) => {\r\n  dispatch({ type: 'LOAD_TODOS_REQUEST' });\r\n  \r\n  try {\r\n    // Mock API call\r\n    await new Promise(resolve => setTimeout(resolve, 500));\r\n    \r\n    // Mock data - in a real app, this would come from an API\r\n    const mockTodos = [\r\n      { id: nextTodoId++, title: 'Complete the project', completed: false, userId: username },\r\n      { id: nextTodoId++, title: 'Prepare for interview', completed: true, userId: username },\r\n      { id: nextTodoId++, title: 'Review React concepts', completed: false, userId: username }\r\n    ];\r\n    \r\n    dispatch({\r\n      type: 'LOAD_TODOS_SUCCESS',\r\n      payload: mockTodos\r\n    });\r\n  } catch (error) {\r\n    dispatch({\r\n      type: 'TODOS_FAILURE',\r\n      payload: error.message\r\n    });\r\n  }\r\n};\r\n\r\nexport const addTodo = (title, username) => async (dispatch) => {\r\n  try {\r\n    // Mock API call\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    \r\n    const newTodo = {\r\n      id: nextTodoId++,\r\n      title,\r\n      completed: false,\r\n      userId: username\r\n    };\r\n    \r\n    dispatch({\r\n      type: 'ADD_TODO_SUCCESS',\r\n      payload: newTodo\r\n    });\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    dispatch({\r\n      type: 'TODOS_FAILURE',\r\n      payload: error.message\r\n    });\r\n    \r\n    return { success: false, error: error.message };\r\n  }\r\n};\r\n\r\nexport const updateTodo = (id, updates) => async (dispatch) => {\r\n  try {\r\n    // Mock API call\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    \r\n    dispatch({\r\n      type: 'UPDATE_TODO_SUCCESS',\r\n      payload: { id, ...updates }\r\n    });\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    dispatch({\r\n      type: 'TODOS_FAILURE',\r\n      payload: error.message\r\n    });\r\n    \r\n    return { success: false, error: error.message };\r\n  }\r\n};\r\n\r\nexport const deleteTodo = (id) => async (dispatch) => {\r\n  try {\r\n    // Mock API call\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    \r\n    dispatch({\r\n      type: 'DELETE_TODO_SUCCESS',\r\n      payload: id\r\n    });\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    dispatch({\r\n      type: 'TODOS_FAILURE',\r\n      payload: error.message\r\n    });\r\n    \r\n    return { success: false, error: error.message };\r\n  }\r\n};\r\n\r\nexport const setTodoFilter = (filter) => ({\r\n  type: 'SET_TODO_FILTER',\r\n  payload: filter\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}